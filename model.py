import pickle

import numpy as np
import xgboost as xgb
from sklearn.metrics import accuracy_score
from sklearn.metrics import confusion_matrix

import utils

# load feature
ngrams_features_list = pickle.load('ngrams_features')
segments_features_set = pickle.load('segments_features')


def represent_file_as_vector(dirpath, filename):
    """
    :param dirpath: path of directory that the given file is in.
    :param filename: name of file, with the extension(= .bytes or .asm) .
    :return: vector of features that represents the given file.
    """
    vec = []

    # ngrams
    curr_ngrams_set = utils.get_ngrams_set_of(dirpath, filename, n=4)
    for feature in ngrams_features_list:
        # TODO current - boolean of 'is ngram in file', optional - how many time ngrams in file
        if feature in curr_ngrams_set:
            vec.append(1)
        else:
            vec.append(0)

    # segments
    seg_counter = utils.count_seg_counts(dirpath, filename, segments_features_set)
    for seg_name in segments_features_set:
        if seg_name in seg_counter:
            vec.append(seg_counter[seg_name])
        else:
            vec.append(0)

    return vec


def represent_files_as_matrix(dirpath, files_list):
    """
    :param dirpath: path to directory that the given files are in.
    :param files_list: list of files-names.
    :return: matrix, each row is np-array representing the ith-file.
    """
    files_vecs = []
    for f_name in files_list:
        vec = represent_file_as_vector(dirpath, f_name)  # represent each file as a vector
        files_vecs.append(vec)
    return np.array(files_vecs)  # convert to np arrays


class CodeModel(object):
    """
    Model that works with code-files, predict the type of file out of 10 possible type.
    """

    def __init__(self, lr=0.1, n_estimators=30, max_depth=5, min_child_weight=1,
                 gamma=0, subsample=0.8, colsample_bytree=0.8, scale_pos_weight=1, seed=27):
        # TODO need to tune the parameters
        self.model = xgb.XGBClassifier(learning_rate=lr,
                                       n_estimators=n_estimators,
                                       max_depth=max_depth,
                                       min_child_weight=min_child_weight,
                                       gamma=gamma,
                                       subsample=subsample,
                                       colsample_bytree=colsample_bytree,
                                       scale_pos_weight=scale_pos_weight,
                                       objective='multi:softprob',
                                       seed=seed)

    def predict_on(self, dirpath, files_list):
        """
        :param dirpath: path to directory that the given file is in.
        :param files_list: list of files-names to predict on.
        :return:
        """
        files_vecs = represent_files_as_matrix(dirpath, files_list)

        # predict
        preds = self.model.predict(files_vecs)
        return [round(val) for val in preds]

    def predict_and_accuracy_on(self, dirpath, files_list, labels, show_confusion_matrix=False):
        """
        :param dirpath: path to directory where the files are in.
        :param files_list: list of files-names
        :param labels:
        :param show_confusion_matrix:
        :return:
        """
        # predict and find accuracy
        preds = self.predict_on(dirpath, files_list)
        acc = accuracy_score(labels, preds)
        print 'accuracy %0.2f%%' % (acc * 100.0)

        # confusion matrix
        if show_confusion_matrix:
            print confusion_matrix(labels, preds)

    def train_on(self, train_tup, dirpath_train, dev_tup, dirpath_dev, model_name=None):
        """
        Fit the model on the train-set and check its performance on dev-set, can save the model after training.
        :param train_tup: tuple of (train-files-list, labels) where the first is list of strings and
        labels is list of numbers, each is the label of ith-file.
        :param dirpath_train: path to directory where the training-files are in.
        :param dev_tup: same format as train_tup.
        :param dirpath_dev: path to directory where the dev-files are in.
        :param model_name: string if needed to save the model,
        the saved model will be in file named by this string, None as default for not saving the model.
        :return:
        """
        # represent data as vector and matrix
        train_list, labels = train_tup
        train_list = represent_files_as_matrix(dirpath_train, train_list)
        labels = np.array(labels)
        # fit model to training data
        self.model.fit(train_list, labels, eval_metric='mlogloss')

        # check performance of model on dev-set
        dev_list, labels = dev_tup
        self.predict_and_accuracy_on(dirpath_dev, dev_list, labels)

        # save model if needed
        if model_name:
            self.save_model(model_name)

    def save_model(self, filename):
        """ save the current model in a file, can be loaded from that file later. """
        pickle.dump(self, open(filename, 'wb'))

    @staticmethod
    def load_from(filename):
        """ load a model from file """
        model = pickle.load(open(filename, 'rb'))
        return model


if __name__ == '__main__':
    print 'hello'
